[{"content":"\n\n  ![](/assets/images/article/2018-04-01/fatherly-love.png)\n\n  父兮生我，母兮鞠我，拊我蓄我，长我育我，顾我复我，出入腹我。欲报之德，昊天罔极。\n\n  愿爸爸否极泰来，早日康复，后福多多！\n","cover":"/assets/images/cover/2018-04-01/blessing.png","link":"article/2018-04-01/devout-blessing.html","preview":"","title":"否极泰来"},{"content":"\n\n  最近，在部署新平台项目的 NODEJS 应用层服务，由于 NODEJS 应用层是一个多端( 移动端、PC 端等 )多业务模块( 多个域名 )混合应用服务。不同的业务模块使用了相对独立的域名，业务层面通过 Namespace 来做了服务隔离。\n\n  在做 Nginx 反代配置时，一时之间懵逼了，发现有近 10 多个域名( 不同的业务模块 )要处理，如果一个一个来，得配置 N 多个 `server` 实例，而且还要同时支持 http 和 https ，并将 http 自动转为 https 。第一时间想到了正则匹配及判断处理，写的时候觉得不够优雅，而且担心效率问题。\n\n  纠结一番后，决定将域名和 Namespace 放配置做一个映射，来简化处理逻辑，于是通过 OR 用 lua 脚本来做了处理。\n\n  折腾完后，在与 W 同学交流中，知道了 Nginx 本身是支持 map 的，没必要使用 lua 脚本来处理这么麻烦。于是，翻了翻 Nginx map 的相关文档，重新优化了配置，干掉了 lua 脚本。\n\n  废话结束，上配置示例：\n\n  ```\n  ......\n\n  map $host $namespace {\n      a.xxx.com        namespace_a;\n      b.xxx.com        namespace_b;\n      c.xxx.com        namespace_c;\n      d.xxx.com        namespace_d;\n      e.xxx.com        namespace_e;\n  }\n\n  upstream node_application {  \n      server     1.1.1.1;  \n      keepalive  16;\n  }\n\n  server {\n\n      listen               443 ssl;\n\n      server_name          a.xxx.com;\n      server_name          b.xxx.com;\n      server_name          c.xxx.com;\n      server_name          d.xxx.com;\n      server_name          e.xxx.com;\n\n      ssl_certificate      xxx.crt;\n      ssl_certificate_key  xxx.key;\n\n      location / {\n\n          proxy_set_header Host $host;\n          proxy_set_header X-Real-IP $remote_addr;\n          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n          proxy_pass http://node_application/$namespace$uri;\n          proxy_http_version 1.1;\n          proxy_set_header Connection \"\";\n\n      }\n\n  }\n\n  server {\n\n      listen               80;\n\n      server_name          a.xxx.com;\n      server_name          b.xxx.com;\n      server_name          c.xxx.com;\n      server_name          d.xxx.com;\n      server_name          e.xxx.com;\n\n      rewrite ^(.*)$  https://$host$1  permanent;\n\n  }\n\n  ......\n  ```\n\n### 参考资料\n\n  \u003chttp://nginx.org/en/docs/http/ngx_http_map_module.html\u003e\n","cover":"/assets/images/cover/2018-03-12/nginx.png","link":"article/2018-03-12/nginx-map-multi-domain-proxy.html","preview":"","title":"Nginx map 实现多域名反代到同一后端服务的不同 Namespace"},{"content":"\n\n  日前，团队小伙伴 D 同学做了 `Javascript 生命周期` 相关主题的分享。  \n  分享会上，小伙伴们围绕 `setTimeout`、`Promise` 及 `process.nextTick` 等内容展开了激烈的讨论。\n  \n  笔者发现小伙伴们忽视了 `setTimeout` 及 `setInterval` 哪些隐秘的坑，于是会上凭借着数年前的记忆对 `setTimeout` 和 `setInterval` 做了一番阐述，由于对一些内容的印象模糊，总觉得解答的不尽人意，对不起观众。  \n  于是，今天抽空又去啃了 MDN Web docs；翻了两本 Javascript 相关书籍。决定对 `setTimeout` 和 `setInterval` 那些被忽视的隐秘知识点做一个总结，同时加深一下印象。\n\n### 用途\n\n  `setTimeout` 是用来延迟执行一个任务，`setInterval` 是用来在一个时间间隔后重复的执行一个任务。\n\n### 最小时间间隔\n\n  `setTimeout` 与 `setInterval` 存在一个最小的时间间隔。\n\n  在 IE 老版本( IE8 以下 )中这个最小时间间隔大约为 15.6ms，后来优化精确到 10ms，IE10+ 为 4ms；  \n  MDN Web docs 中提到，Firefox 中这个最小时间间隔为 10ms，Firefox 18+ 的测试时间约为 4ms；  \n  Chrome、Opera、Safari 等测试数据显示这个最小时间间隔约为 4ms；  \n  HTML5 新的标准规定 `setTimeout` 的最小时间间隔为 4ms，`setInterval` 的最小时间间隔为 10ms。\n\n  实际应用中：  \n  ▪ 如果参数设定的时间间隔时间小于浏览器设定的默认最小时间间隔，那么浏览器会按照默认的最小时间间隔来处理；  \n  ▪ 如果回调的执行时间大于间隔时间，那么回调会继续执行，导致真正的时间间隔比原来设定的会大一点。\n\n### 一些旧版本浏览器的优化方案\n\n  对于一些老版本的浏览器 15ms+ 的最小时间间隔如果觉得间隔时间太大，那么我们可以考虑重写 `setTimeout` 等方法。  \n  下面的例子利用 image 出现死链时立即触发执行 onerror 的机制重写了默认的 `setTimeout`:\n\n  ```\n  var originalSetTimeOut = window.setTimeout;\n  \n  window.setTimeout = function( callback, time ) {\n      if( time \u003c 15 ) {\n          originalSetTimeOut( callback, time );\n      }\n      else {\n          var IMG = new Image();\n\n          IMG.onload = IMG.onerror = function() {\n              callback();\n          }\n\n          IMG.src = \"data:,error\";\n      }\n  };\n  ```\n\n### 零秒延迟\n\n  在某些情况下，我们希望被延迟的任务能够在较短的时间后被执行，我们会指定一个很小的间隔时间，甚至将时间设置为 `0` 值。  \n  但是零秒延迟并不是真的会立即被执行，上面我们提到了浏览器会有一个最小的时间间隔设定。\n\n  那么零秒延迟到底有什么用呢？\n\n  我们知道，Javascript 在执行过程中会针对异步代码创建任务队列，`setTimeout(fn, 0)` 就是告诉浏览器“尽可能快”的去执行指定的回调任务，实现一个插队操作。\n\n### 省略时间参数的情况\n\n  实际应用中，如果不指定第二个间隔时间参数，浏览器会自动分配一个间隔时间。\n\n  IE 和 Firefox 中，浏览器第一次可能会分配一个较大的间隔时间，约为 100ms，往后会减小到上面所说的最小时间间隔；  \n  FireFox 中，`setInterval` 如果不指定第二个时间参数，会当作 `setTimeout` 处理，即只会执行一次。\n\n  Chrome、Opera、Safari 浏览器分配的间隔时间约为 10ms。\n\n### 额外的参数( 不止两个参数 )\n\n  IE10+ 和标准浏览器，除支持 `callback` 和 `time` 两个参数外，还支持额外的参数，作为回调函数的参数( 即第一个参数 callback 的参数 )。\n\n  ```\n  setTimeout(function() {\n      console.log( [].slice.call( arguments ) );\n  }, 100, \"A\", \"B\", \"C\");\n  ```\n\n### 时间参数极端值的情况\n\n  如果时间参数为负数、极小极小的负数或极大的正数，各种浏览器的处理会出现比较大的出入，会出现立即执行或“不执行”( 是否真的不执行有待深究 )的情况。\n\n  感兴趣的话可以自己做些测试。\n\n### 其他的一些影响因素\n\n  ▪ 此外，浏览器的后台模式运行，页面窗口非活动状态( 页面不处于当前浏览窗口 ) 时，浏览器会对间隔时间做一些优化调整( 间隔时间会被调整到 1000ms )；  \n  ▪ 同时，对于一些移动设备操作系统为了体验优化或节能状态下时，这个间隔时间也会受到影响；  \n  ▪ 笔记本电脑，在没有外部电流供电仅靠电池供电状态下，浏览器也会对间隔时间做一些调整。\n\n### 参考资料\n\n  ▪ \u003chttps://testdrive-archive.azurewebsites.net/Performance/setImmediateSorting/Default.html\u003e  \n  ▪ \u003chttps://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\u003e  \n  ▪ \u003chttps://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\u003e\n","cover":"/assets/images/cover/2017-12-02/timer.png","link":"article/2017-12-02/javascript-timer.html","preview":"\u003cp\u003esetTimeout 与 setInterval 那些不为人知的隐秘知识点。\u003c/p\u003e\n","title":"setTimeout \u0026 setInterval"},{"content":"\n\n  Golang 使用 `package` 作为最基本的分发单位来组织源码。\n\n  每个 Go 源码文件都会以 `package xxx` 的声明开头；同时也是定义( 声明 )一个 `package` ( 包 )。\n\n### 包的拆分\n\n  Golang 中的每个 `package` 都会有一个对应的目录；  \n  对于一个 `package` 可以不局限于单一的文件，可以拆分由多个文件组成；  \n  组成同一个 `package` 的多个文件必须使用相同的 `package name` 并在同一级目录中。\n\n  注：  \n  ▪ 组成同一个 `package` 的多个文件，编译后会合并为一个文件，因此组成同一个 `package` 的不同文件之间可以直接引用函数和变量( 不论是否导出 )，\n  同时组成包的多个文件中不能有相同的全局变量和函数( init 是一个特例 )；  \n  ▪ 同一级目录中只能存在一个 `package`( 即：同一级目录中多个文件的包名必须保持一致 )。\n\n### 包级访问权限\n\n  包中定义的全局变量或函数，首字母小写，则表示是包级私有的，如果首字母大写，则可以在其他包中被访问到。\n\n### 包的导入\n\n  Golang 提供了关键字 `import` 用来导入第三方的包和标准库的包。\n\n  你可以通过如下两种分方式来 `import` package:\n\n  ```\n  // Way one:\n  import \"gopkg.in/mgo.v2\"\n  import \"time\"\n  \n  // Way two:\n  import (\n      \"gopkg.in/mgo.v2\"\n      \"time\"\n  )\n  ```\n\n  注：  \n  ▪ 对于 Golang 的标准库包，会从 GOROOT 中去寻找并导入指定的包；  \n  ▪ 对于第三方包或自己编写的项目模块，你可以使用`相对路径`或`绝对路径`的方式来导入，但是实际使用中是不推荐`相对路径`的方式来导入包。\n\n### import 包的别名\n\n  有时候我们为了便于记忆或编码中一些特殊的意义考量，我们可以在导入包的时候给包取一个别名。\n\n  ```\n  import (\n      f \"fmt\"\n      t \"time\"\n  )\n\n  f.Println( t.Now() )\n  ```\n\n  注：如果导入包时使用了别名，那么调用包函数或变量时就要使用我们指定的别名。\n\n### import 时的 `.` ( 点操作符 ) \n\n  有时候我们希望在调用导入的包的函数时省略掉包名作为前缀，这时候你可以在导入包时使用 `.` 操作符来达到你的目的。\n\n  ```\n  import (\n      . \"fmt\"\n  )\n\n  Println( \"我省略了包名 fmt\" )\n  ```\n\n### import 时的 `_` ( 下划线操作符 ) \n\n  有时候我们在导入一个包时，仅仅希望它的 `init()` 被调用执行，那么你可以使用 `_` 操作符来达到你的目的。\n\n  ```\n  import (\n      _ \"gopkg.in/xxx\"\n  )\n  ```\n\n  注：使用 `_` 操作符来导入包时，无法通过包名来访问包中的函数和变量。\n\n### 特殊的 main 包\n\n  包名为 `main` 的 `package` ，可以生成可执行程序，并且 `main` 包中必须包含一个名为 `main` 的函数。\n\n  ```\n  package main\n\n  import (\n      \"fmt\"\n      \"time\"\n  )\n\n  func main() {\n      fmt.Println( time.Now() )\n  }\n  ```\n\n### 需要注意的点\n\n  ▪ `import` 一个包但是未使用的话会编译报错；  \n  ▪ `import` 关键字导入包时导入的是包的路径，而不是包名，通常情况下我们会将包的路径末端目录名和包名习惯性的使用相同的命名，容易给人产生错觉，误认为路径末端目录名就是包名，但实际上这两者不是同一个东西，命名也可以不一致。\n","cover":"/assets/images/cover/2017-12-01/package.png","link":"article/2017-12-01/go-package.html","preview":"","title":"Golang - Package"},{"content":"\n\n### GOPATH\n\n  GOPATH 为 GO 的一个重要的环境变量。\n\n  GOPATH 作为 `import` 包时的搜索路径，同时也是项目源代码和二进制文件的目录，`go get`、`go install` 和 GO 的一些其他工具都会用到 GOPATH。\n\n### GOPATH 设置\n\n  GOPATH 为一个路径，支持多个，因此也可以说 GOPATH 是一个路径列表。\n\n  GOPATH 默认保持和 GOROOT 一致的值，从 Go 1.1 版本开始，必须修改为其它路径。\n\n  当有多个 GOPATH 路径时，需要用分隔符分隔不同的路径：\n\n  - Windows 分隔符为 `;`\n\n  ```\n  GOPATH=X:\\Go\\A;X:\\Go\\B\n  ```\n\n  - 类 Unix 系统和 Mac 为 `:`\n\n  ```\n  export GOPATH=$HOME/Go/A:$HOME/Go/B\n  ```\n\n  ( 注: 当有多个 GOPATH 路径时，`go get` 获取的包将默认存放在第一个路径目录下。 )\n\n### 目录说明\n\n  GOPATH 目录一般会有三个子目录。\n\n  - bin 经过编译的可执行文件目录\n  - pkg 编译时生成的中间文件( 如：.a 文件 )\n  - src 用于存放项目源代码( 如：.go .h .c 等源码 )\n","cover":"/assets/images/cover/2017-11-19/gopath.png","link":"article/2017-11-19/go-gopath.html","preview":"","title":"Golang - GOPATH"},{"content":"\n\n  ![{ 用键盘敲出个五彩斑斓的人生 }](/assets/images/cover/2017-11-18/keyboard.png)\n","cover":"/assets/images/cover/2017-11-18/keyboard.png","link":"article/2017-11-18/hello-world.html","preview":"","title":"HELLO WORLD"}]